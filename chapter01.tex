\chapter{Кіріспе}

Спорттық бағдарламалау екі тақырыпты қамтиды:
(1) алгоритмдерді жобалау және (2) оларды жүзеге асыру.

\key{Алгоритмдерді жобалау} есеп шығару мен математикалық ойлаудан тұрады.
Есеп шығару барысында креативті көзқарас пен талдау жасай алу қабілеті қажет.
Есептің шешімі болатын алгоритм тиімді әрі дұрыс болуы тиіс, 
көбіне есептердің түпкі мақсаты оңтайлы алгоритмді анықтауға құрылады.

Теория -- спорттық бағдарламалаушы үшін маңызды бөлім. 
Есептің шешімі -- дұрыс пайдаланылған білім мен идеяның жемісі.
Спорттық бағдарламалауда кездесетін кей әдістер алгоритмдерді тереңірек зерттеудің негізін қалыптастырады.

Жақсы бағдарлама жаза білу қабілеті \key{алгоритмдерді жүзеге асыруға} 
үлкен әсерін тигізеді.
Спорттық бағдарламалауда есеп шешімі тест жиыны арқылы тексеріледі.
Сондықтан алгоритм идеясы мен жазылуының дұрыс болуы шарт.

Бағдарламалау жарыстарындағы (контесттерде) ең жақсы код стиліне ''қарапайым да жинақы жазу'' жатады. 
Уақыттың шетеулі болуына байланысты бағдарламаны тез жазған абзал.
Инженерлік бағдарламалауға қарағанда бұл жерде код қысқа болады (әдетте максималды мөлшері бірнеше жүздеген жолдан тұрады), әрі жарыстан кейін ары қарай сүйемелдеуді қажет етпейді.

\section{Бағдарламалау тілдері}

\index{programming language}

Қазіргі таңда бағдарламалау жарыстарында (контесттерде) С++, Python, Java тілдері жиі қолданылады. 
Мысалы, Google Code Jam 2017 жарысында
3000 үздік қатысушылардың арасында
79 \% C++,
16 \% Python,
8 \%  Java \cite{goo17} тілдерін қолданған.
Қалған пайызы өзге тілдерді пайдаланған.

Көп адам С++ тілін спорттық бағдарламалау 
үшін ең қолайлы тіл деп есептейді
және С++ барлық дерлік контесттер жүйесінде кездеседі.
Бұл тілдің артықшылығы – тілдегі алгоритмдер мен деректер 
құрылымының үлкен жиынтығы болуында. Сондай-ақ С++ тілінде кодтың жылдамырақ жұмыс істеуі де бұл тілдің тиімділігін арттырады.  

Бір жағынан бірнеше тілде жаза алудың өз 
тиімді тұстары да бар. 
Мысалы, есепте үлкен сандармен жұмыс жасау керек болса,
Python ұтымды таңдау болмақ. Себебі оның ішіне үлкен сандармен жұмыс жасайтын
операциялар кіріктірілген.
Дегенмен контесттерде есептер барлық тілдерде шешім табуға болатындай етіп
құрастырылатынын ұмытпағанымыз жөн.

Мысал ретінде берілген барлық кодтар С++ - те жазылып отыр және көбіне стандартты дерекханадағы алгоритмдер мен деректер құрылымдары қолданылады.
Кітапта жазылған кодтар барлық заманауи контесттерде кездесетін  С++11 стандартты нұсқасына сай келеді.

Егер сіз әлі С++ - пен таныс болмасаңыз, осы тілді меңгере бастауыңызға қолайлы сәт енді туды деп санауыңызға болады.

\subsubsection{C++ код үлгісі}

Жиі кездесетін С++ код үлгісі:

\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;

int main() {
    // solution comes here
}
\end{lstlisting}

Кодтың ең жоғарғы бөлігінде жазылған \texttt{\#include} 
жолы -- \texttt{g++} компиляторының ерекшілігі.
Оның көмегімен барлық стандартты дерекханаларды пайдалана аламыз.
\texttt{iostream}, \texttt{vector} және \texttt{algorithm}
сияқты дерекханалардың әрқайсысын жеке-дара жазу қажеттілігі туындамайды,
бірден автоматты түрде қолдана аламыз.

\texttt{using} жолы стандартты дерекхана кластары
мен функциялары тікелей әрекет ете алатындығын көрсетеді.  
Онсыз \texttt{cout} орнына \texttt{std::cout} 
деп жазып отыруға тура келер еді.

Келесі команда арқылы код компиляциядан өтеді:

\begin{lstlisting}
g++ -std=c++11 -O2 -Wall test.cpp -o test
\end{lstlisting}

Команда \texttt{test.cpp} кодынан
\texttt{test} бинарлық файлын қайтарады.
Компилятор C++11 стандартын қолданады
(\texttt{-std=c++11}),
кодты оңтайландырады (\texttt{-O2})
және туындауы мүмкін ескертулерге нұсқайды (\texttt{-Wall}).

\section{Енгізу (input) мен шығару (output)}

\index{Енгізу (input) мен шығару (output)}

Көбіне контесттерде енгізу мен шығару үшін 
стандартты ағындарды пайдаланады.
С++ үшін стандартты ағындар :
\texttt{cin} енгізу үшін, \texttt{cout} шығару үшін.
Сонымен қатар C функциялары
\texttt{scanf} пен \texttt{printf} - ті пайдалануға болады.

Әдетте енгізу бос орын не жаңа жолдар арқылы ажыратылған сандар мен жолдардан (string) тұрады.
Олар мысалдағыдай \texttt{cin} арқылы оқылады:

\begin{lstlisting}
int a, b;
string x;
cin >> a >> b >> x;
\end{lstlisting}

Енгізуде әр элемент ең кем дегенде бос 
орынмен немесе жаңа жолмен бөлінгендіктен, әрдайым осы тәріздес кодтар жұмыс істейді.

Мысалы, жоғарыдағы код келтірілген мына екі енгізуді де қабылдай алады:
\begin{lstlisting}
123 456 monkey
\end{lstlisting}
\begin{lstlisting}
123    456
monkey
\end{lstlisting}
\texttt{cout} ағымы осы жердегідей шығару үшін пайдаланылады:
\begin{lstlisting}
int a = 123, b = 456;
string x = "monkey";
cout << a << " " << b << " " << x << "\n";
\end{lstlisting}

Дәл осы енгізу мен шығару бағдарламаның тиімді жұмыс жасауына кейде кедергі келтіреді.
Ал төмендегі жолдар кедергіге қарсы әрекет етеді:

\begin{lstlisting}
ios::sync_with_stdio(0);
cin.tie(0);
\end{lstlisting}

Тағы да ескеретін бір жайт бар. \texttt{"\textbackslash n"}
\texttt{endl} - ке қарағанда тезірек жұмыс жасайды,
өйткені \texttt{endl} әрдайым буферді арылтып отырады.

C функциялары \texttt{scanf}
пен \texttt{printf} С++ - тің стандартты ағымдарына балама ретінде қолданылады.
С функциялары салыстырмалы түрде жылдамырақ жұмыс жасағанымен, қолданыста біраз қиындық тудырады.
Төмендегі код екі сан енгізеді:
\begin{lstlisting}
int a, b;
scanf("%d %d", &a, &b);
\end{lstlisting}
Ал келесі код керісінше екі сан шығарады:
\begin{lstlisting}
int a = 123, b = 456;
printf("%d %d\n", a, b);
\end{lstlisting}

Кейде бағдарлама бір жолды толығымен, яғни бос орындармен бірге оқуы тиіс болады.
Осындай кезде \texttt{getline} функциясын қолданамыз:

\begin{lstlisting}
string s;
getline(cin, s);
\end{lstlisting}

Егер енгізу саны нақты болмаса, келесі цикл пайдалы:
\begin{lstlisting}
while (cin >> x) {
    // code
}
\end{lstlisting}
Бұл цикл енгізу деректері аяқталмайынша, стандартты енгізудегі барлық элементтерді қабылдай береді.

Кей контесттерде енгізу мен шығару файл ретінде беріледі.
Мұндай жағдайда стандартты шығару мен енгізуді пайдаланып,
төменде көрсетілген код жолдарын жазған абзал:
\begin{lstlisting}
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
\end{lstlisting}
Осыдан кейін бағдарлама енгізуді
''input.txt'' файлынан қабылдап,
шығаруды ''output.txt'' файлында шығарады.

\section{Сандармен жұмыс}

\index{бүтін сандар}

\subsubsection{Бүтін сандар}

Бүтін сандардың ең жиі қолданылатын түрі --
\texttt{int}. Ол -- мәні $-2^{31} \ldots 2^{31}-1$
арасындағы (шамамен $-2 \cdot 10^9 \ldots 2 \cdot 10^9$) 
бүтін сандарды қамтитын 32 биттік деректер типі.
Егер \texttt{int} деректер типінен орасан үлкен/кіші сандарды
сақтағыңыз келсе, 64 биттік \texttt{long long} деректер
типін қолдана аласыз. Оның қамтитын ауқымы 
-- $-2^{63} \ldots 2^{63}-1$
(шамамен $-9 \cdot 10^{18} \ldots 9 \cdot 10^{18}$).

Төмендегі код \texttt{long long} типтік 
айнымалысын орнатады:
\begin{lstlisting}
long long x = 123456789123456789LL;
\end{lstlisting}
\texttt{LL} суффиксі санның типі 
\texttt{long long} екенін көрсетеді.

\texttt{long long} қолданысындағы кең 
таралған қателердің бірі --
\texttt{int} типін жаңылысып қолдану. 
Мысалы, төменегі кодта қате бар:

\begin{lstlisting}
int a = 123456789;
long long b = a*a;
cout << b << "\n"; // -1757895751
\end{lstlisting}

\texttt{b} айнымалысы \texttt{long long} болғанымен,
\texttt{a*a} өрнегіндегі айнымалылардың типі \texttt{int}
болғандықтан, олардың көбейтіндісі де \texttt{int} болады.
Сондықтан \texttt{b} айнымалысына қате нәтиже сақтайды.
Қатені дұрыстау үшін \texttt{a} айнымалысының типін
\texttt{long long} ауыстырсақ жеткілікті немесе 
өрнекті \texttt{(long long)a*a} деп өзгертсек те болады.

Контесттегі есептердің шешуіне әдетте \texttt{long long} 
жеткілікті. Дегенмен \texttt{g++} компиляторында 
128 биттік типтік \texttt{\_\_int128\_t} деректер типін
қолдануға болады. Оның қамтитын ауқымы --
$-2^{127} \ldots 2^{127}-1$ (шамамен $-10^{38} \ldots 10^{38}$).
Бірақ, бұл деректер типі барлық контест
жүйелерінде қол жетімді емес.

\subsubsection{Модульдік арифметика}

\index{қалдық}
\index{модульдік арифметика}

Біз $x \bmod m$ деп $x$ - ті $m$ - ге 
бөлгендегі қалдықты белгілейміз.
Мысалы, $17 \bmod 5 = 2$,
себебі $17 = 3 \cdot 5 + 2$.

Кей есептердің жауабы тым үлкен сан болуы мүмкін. Сондай жағдайда есептің шартына сәйкес жауапты ''модуль $m$'' арқылы алуға болады. 
(мысалы, ''модуль $10^9+7$'').
Мұндағы идея жауаптың үлкендігіне қарамастан 
\texttt{int} және \texttt{long long} типтерін қолданудың жеткілікті екендігіне негізделеді.

Қалдықтың маңызды қасиеті -- 
қосу, азайту және көбейту
операцияларын орындамастан 
бұрын қалдықты алдын-ала есептеу мүмкіндігі келесі формулалар арқылы көрінеді:

\[
\begin{array}{rcr}
(a+b) \bmod m & = & (a \bmod m + b \bmod m) \bmod m \\
(a-b) \bmod m & = & (a \bmod m - b \bmod m) \bmod m \\
(a \cdot b) \bmod m & = & (a \bmod m \cdot b \bmod m) \bmod m
\end{array}
\]

Осылайша біз әр операциядан кейін қалдық есептеу арқылы
тым үлкен сан шықпауын қадағалаймыз.

Мысалы, $n!$ коды $n$ факториалын $m$ модулінде есептейді:
\begin{lstlisting}
long long x = 1;
for (int i = 2; i <= n; i++) {
    x = (x*i)%m;
}
cout << x%m << "\n";
\end{lstlisting}

Әдетте қалдықтың $0\ldots m-1$ аралығында
болғанын қалаймыз.
Алайда С++ және басқа тілдерде теріс сандардың 
қалдығы нөлге тең немесе теріс сандар болады.
Қалдықтың теріс сан болмауын қадағалаудағы оңай жол –
алдымен жай қалдықты есептеу, кейін жауап теріс болса,
$m$ - ді қосу:
\begin{lstlisting}
x = x%m;
if (x < 0) x += m;
\end{lstlisting}
Дегенмен бұл жол кодта азайту болған жағдайда ғана қолданылады.
Басқа жағдайларда теріс санды қалдыруға болады.

\subsubsection{Қалқымалы нүктелі сандар}

\index{қалқымалы нүктелі сандар}

Әдетте спорттық бағдарламалауда кездесетін қалқымалы
нүктелі сандар -- деректер типі 64 биттік \texttt{double}
мен \texttt{g++} компиляторындағы кеңейтілімі
80 биттік \texttt{long double}.
Көп жағдайда \texttt{double} жеткілікті болғанымен, \texttt{long double} дәлірек келеді.

Талап етілетін жауап дәлдігі негізінен есеп шартында беріледі.
Жауапты шығарудың оңай жолы –  \texttt{printf} функциясын пайдаланып,
нүктеден кейінгі сан мөлшерін форматтау жолында көрсету.
Мысалы, төмендегі код $x$ - ті нүктеден кейінгі 9 орынмен бірге шығарады:

\begin{lstlisting}
printf("%.9f\n", x);
\end{lstlisting}

Қалқымалы нүктелі сандарды қолдану барысындағы қиындықтар
кейбір сандардың дәлдігі мен ықшамдау кезінде туындайтын қателермен байланысты болып келеді.
Мысалы, келесі код күтпеген нәтиже береді:

\begin{lstlisting}
double x = 0.3*3+0.1;
printf("%.20f\n", x); // 0.99999999999999988898
\end{lstlisting}

Ықшамдау қателігі \texttt{x} - тің мәнін дұрыс жауабында дәл 1-ге тең екеніне қарамастан, 1 - ден сәл кішірек етіп көрсетеді.

Қалқымалы нүктелі сандарды \texttt{==} операторы 
арқылы салыстыру біраз қауіпті,  өйткені дәлдік қатесінің әсерінен тең сандар дұрыс тексерілмеуі мүмкін.
Оларды салыстырудың ұтымды жолы – екі санның айырмашылығы $\varepsilon$ - ден 
көп болмаса, тең деп есептеу.
Бұл жердегі $\varepsilon$ –кішкентай сан.

Қолданыстағы сандарды осылай салыстыруға болады: ($\varepsilon=10^{-9}$):

\begin{lstlisting}
if (abs(a-b) < 1e-9) {
    // a and b are equal
}
\end{lstlisting}

Қалқымалы нүктелі сандардың дәлдікпен сақталу мүмкіндігі болмаса да,
бүтін сандарды белгілі мәндер аралығында жоғары дәлдікпен сақтай аламыз.
Мысалы, \texttt{double} - ды қолданып,
бүтін сандарды $2^{53}$ мәніне дейін сақтай аламыз.

\section{Кодты ықшамдау}

Кодты ықшамдап жазу -- спорттық бағдарламалау үшін аса маңызды тәсіл. Себебі бағдарламаны барынша тез жазған абзал.
Сондықтан спорттық бағдарламалаушылар әдетте
деректер типтерін қысқа атаулармен алмастырады және 
кодтың өзге бөліктеріне де қысқа атаулар береді.

\subsubsection{Тип атаулары}
\index{tuppdef@\texttt{typedef}}
\texttt{typedef} командасын қолдану арқылы
деректер типіне қысқа атау беруге болады.
Мысалы, \texttt{long long} тым ұзақ,
оны \texttt{ll} деп қысқарттық:
\begin{lstlisting}
typedef long long ll;
\end{lstlisting}
Төмендегі код:
\begin{lstlisting}
long long a = 123456789;
long long b = 987654321;
cout << a*b << "\n";
\end{lstlisting}
Осылай қысқара алады:
\begin{lstlisting}
ll a = 123456789;
ll b = 987654321;
cout << a*b << "\n";
\end{lstlisting}

\texttt{typedef} командасын
өзге күрделірек типтер үшін де пайдалануға болады. Мысалы, төмендегі кодтағы \texttt{vi} атауы бүтін санды векторды, ал
 \texttt{pi} екі бүтін санды сақтауға арналған жұпты білдіреді.
\begin{lstlisting}
typedef vector<int> vi;
typedef pair<int,int> pi;
\end{lstlisting}

\subsubsection{Макростар}
\index{макрос}
Кодты ықшамдаудың тағы бір жолына
\key{макростарды} қолдану жатады.
Макрос компиляциялауға дейін белгілі бір жолдардың 
өзгеретінін білдіреді.
C++ - та макростар \texttt{\#define} кодсөзі 
арқылы анықталады.

Мысалы, төменде көрсетілген макростарды кодта қолдана аламыз:
\begin{lstlisting}
#define F first
#define S second
#define PB push_back
#define MP make_pair
\end{lstlisting}
Осыдан кейін кодты
\begin{lstlisting}
v.push_back(make_pair(y1,x1));
v.push_back(make_pair(y2,x2));
int d = v[i].first+v[i].second;
\end{lstlisting}
осылай ықшамдай аламыз:
\begin{lstlisting}
v.PB(MP(y1,x1));
v.PB(MP(y2,x2));
int d = v[i].F+v[i].S;
\end{lstlisting}

Сондай-ақ макростардың циклдер мен басқа да
құрылымдарды қысқарта алатын параметрлері болуы мүмкін.
Үлігі ретінде макростың бір нұсқасын берейік:
\begin{lstlisting}
#define REP(i,a,b) for (int i = a; i <= b; i++)
\end{lstlisting}
Ол төмендегі кодты
\begin{lstlisting}
for (int i = 1; i <= n; i++) {
    search(i);
}
\end{lstlisting}
осылай ықшамдай алады:
\begin{lstlisting}
REP(i,1,n) {
    search(i);
}
\end{lstlisting}

Кейде макрос анықталуы қиын қателерді туындатуы мүмкін.
Мысалы, санның квадратын есептейтін макросты қарастырайық:
\begin{lstlisting}
#define SQ(a) a*a
\end{lstlisting}
Бұл макрос әрдайым күткеніміздей \emph{жұмыс жасамайды}.
Мына кодты қарастырайық:
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
сәйкесінше:
\begin{lstlisting}
cout << 3+3*3+3 << "\n"; // 15
\end{lstlisting}

Макростың дұрысырақ жазылған нұсқасы:
\begin{lstlisting}
#define SQ(a) (a)*(a)
\end{lstlisting}
Ал енді төмендегі код:
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
келесі өрнекке өзгереді
\begin{lstlisting}
cout << (3+3)*(3+3) << "\n"; // 36
\end{lstlisting}


\section{Математика}

Математиканың спорттық бағдарламалаудағы рөлі орасан зор,
сондықтан да математикалық ойлау қабілетінсіз бұл салада үздік болу мүмкін емес.
Бұл бөлімде алдағы уақытта қажет болатын тұжырымдамалар мен формулаларды талдаймыз.

\subsubsection{Қосынды формуласы}

\[\sum_{x=1}^n x^k = 1^k+2^k+3^k+\ldots+n^k,\]
формасындағы $k$ бүтін сан болған жағдайда,
қосындының формуласын $k+1$ дәрежесіндегі 
көпмүше арқылы келтіре аламыз.
Мысалы, \footnote{\index{Фаульхабер формуласы}
Осындай қосындылар үшін жалпы формула - Фаульхабер формуласы бар.
Бірақ ол күрделі болғандықтан кітапта көрсетілмеді.},
\[\sum_{x=1}^n x = 1+2+3+\ldots+n = \frac{n(n+1)}{2}\]
және
\[\sum_{x=1}^n x^2 = 1^2+2^2+3^2+\ldots+n^2 = \frac{n(n+1)(2n+1)}{6}.\]

\key{Арифметикалық прогрессия} -- \index{арифметикалық прогрессия}
әр екі көршілес тұрған санның айырмасы тұрақты санға тең болатын тізбек.
Төмендегі тізбек --
\[3, 7, 11, 15\]
тұрақты саны 4 болатын арифметикалық прогрессия.
Арифметикалық прогрессиялы тізбектің сомасын табатын формула:
\[\underbrace{a + \cdots + b}_{n \,\, \textrm{numbers}} = \frac{n(a+b)}{2}\]
$a$ -- ең алғашқы,
ал $b$ -- ең соңғы сан болса,
$n$ -- тізбектегі сандар мөлшері.
Мысалы,
\[3+7+11+15=\frac{4 \cdot (3+15)}{2} = 36.\]
тізбегінің тұрақты саны 4.
Формулада $n$ саннан тұратын тізбектегі әр сан орташа 
есеппен $(a+b)/2$ тең екенін негізге аламыз.

\index{Геометриялық прогрессия}
\key{Геометриялық прогрессия} -- әр көршілес санның қатынасы тұрақты болатын сандар тізбегі.

Төмендегі тізбек:
\[3,6,12,24\]
тұрақты саны 2-ге тең геометриялық прогрессия.
Қосындысын есептеу формуласы:
\[a + ak + ak^2 + \cdots + b = \frac{bk-a}{k-1}\]
$a$ -- алғашқы сан,
$b$ -- соңғы сан, ал $k$ -- екі көршілес санның қатынасы.
Мысалы,
\[3+6+12+24=\frac{24 \cdot 2 - 3}{2-1} = 45.\]

Формуланың шығу жолы:
\[ S = a + ak + ak^2 + \cdots + b .\] болса,
екі жақты $k$ санына көбейтсек
\[ kS = ak + ak^2 + ak^3 + \cdots + bk,\] өрнегі пайда болады.
Теңдеуді шешу арқылы
\[ kS-S = bk-a\]
формуласы қалады.

Геометриялық прогрессияның қосындысы үшін дербес жағдай формуласы:
\[1+2+4+8+\ldots+2^{n-1}=2^n-1.\]

\index{Гармоникалық қосынды}

\key{Гармоникалық қосынды} -- 
\[ \sum_{x=1}^n \frac{1}{x} = 1+\frac{1}{2}+\frac{1}{3}+\ldots+\frac{1}{n}.\]
формасындағы қосынды.
Гармоникалық қосындының үстіңгі шегі $\log_2(n)+1$. % HERE
Анығырақ айтсақ, әр $1/k$ өрнегіндегі
$k$ санын $k$-дан аспайтын және оған ең жақын болатын 2-нің
дәрежесіне ауыстырамыз.
Мысалы, $n=6$ болған жағдайда қосындының өзгерісі:
\[ 1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\frac{1}{5}+\frac{1}{6} \le
1+\frac{1}{2}+\frac{1}{2}+\frac{1}{4}+\frac{1}{4}+\frac{1}{4}.\]
Жоғарғы шек $\log_2(n)+1$ бөліктен тұрады
($1$, $2 \cdot 1/2$, $4 \cdot 1/4$... ),
және ең көп дегенде әр бөлік 1-ге тең болады.

\subsubsection{Жиын теориясы}

\index{жиын теориясы}
\index{жиын}
\index{қиылысу}
\index{бірігу}
\index{айырмашылық}
\index{ішжиын}
\index{әмбебап жиын}
\index{толықтауыш}

\key{Жиын} -- элемменттер топтамасы.
Мысалы,
\[X=\{2,4,7\}\] жиыны
2, 4 және 7 элементтерін қамтиды.
$\emptyset$ символы бос жиынды,
ал $|S|$ $S$ жиындардың өлшемін, яғни
элементтер санын көрсетеді.
Мысалға қайта оралсақ, $|X|=3$.

$S$ жиыны $x$ элементін қамтитынын
$x \in S$ белгісімен көрсетеміз,
кері нұсқасы -- $x \notin S$.
Жоғарыда қарастырған жиынға қатысты мысал:
\[4 \in X \hspace{10px}\textrm{және}\hspace{10px} 5 \notin X.\]

\begin{samepage}
Жиын операциялары арқылы жаңа жиындар құрастыра аламыз:
\begin{itemize}
\item $A \cap B$ \key{қиылысуы} $A$ және $B$ жиындарының екеуіне де тән
элементтерден құралған.
Мысалы, $A=\{1,2,5\}$, $B=\{2,4\}$.
Сәйкесінше, $A \cap B = \{2\}$.
\item $A \cup B$ \key{бірігуі} -- екі жиында да 
немесе кем дегенде екеуінің бірінде кездестін элементтерді қамтиды.
$A=\{3,7\}$ және $B=\{2,3,8\}$ жиындары болса,
олардың бірігу үлгісі: $A \cup B = \{2,3,7,8\}$.
\item $\bar A$ \key{толықтауышы} -- $A$ жиынында жоқ элементтер.
Толықтауыштың түсіндірмесі болуы мүмкін барлық элементтерді қамтитын
\key{әмбебап жиынға} тәуелді.
Егер $A=\{1,2,5,7\}$, ал әмбебап жиын
$\{1,2,\ldots,10\}$ болса, $\bar A = \{3,4,6,8,9,10\}$.
\item  $A \setminus B = A \cap \bar B$ \key{айырмашылығы} --
$A$ жиынында болғанымен $B$ жиынында жоқ элементтер.
Бұл жерде $B$ элементтері $A$ элементтерінің қатарында жоқ екендігіне назар аудару керек:
Егер $A=\{2,3,7,8\}$ және $B=\{3,5,8\}$
болса, $A \setminus B = \{2,7\}$.
\end{itemize}
\end{samepage}

$A$ элементтері толықтай $S$ жиынына кірсе,
$A$ $S$-тің \key{ішжиыны},
белгіленуі: $A \subset S$.
$S$ жиынында бос жиындарды санағанда 
әрдайым $2^{|S|}$ ішжиын бар.
Мысалы, $\{2,4,7\}$ үшін ішжиындар:
\begin{center}
$\emptyset$,
$\{2\}$, $\{4\}$, $\{7\}$, $\{2,4\}$, $\{2,7\}$, $\{4,7\}$ және $\{2,4,7\}$.
\end{center}

Жиі қолданылатын жиындар:
$\mathbb{N}$ (натурал сандар),
$\mathbb{Z}$ (бүтін сандар),
$\mathbb{Q}$ (рационал сандар) мен
$\mathbb{R}$ (нақты сандар).
$\mathbb{N}$ жиынын туындаған жағдайға байланысты
екі түрде қарастыра аламыз:
$\mathbb{N}=\{0,1,2,\ldots\}$
немесе $\mathbb{N}=\{1,2,3,...\}$.

Сонымен қатар жиынды келесі форманы қолдану арқылы құрастыра аламыз:
\[\{f(n) : n \in S\},\]
$f(n)$ қандай да бір функцияны меңзейді.
Жиын $f(n)$ формасындағы барлық мүмкін мәндерді қамтиды,
$n$ $S$ элементі.
Үлгідегі жиын барлық жұп сандарды қамтиды:
\[X=\{2n : n \in \mathbb{Z}\}\]

\subsubsection{Логика}

\index{логика}
\index{терістеу}
\index{конъюкция}
\index{дизъюнкция}
\index{импликация}
\index{эквиваленттеу}

Логикалық өрнектің тек \key{true} (1)
немесе \key{false} (0) мәндері бар.
Ең маңызды логикалық операциялар:
$\lnot$ (\key{терістеу}),
$\land$ (\key{конъюкция}),
$\lor$ (\key{дизъюнкция}),
$\Rightarrow$ (\key{импликация}) мен
$\Leftrightarrow$ (\key{эквиваленттеу}).
Төмендегі кестеде операторлар мағыналарымен көрсетілген:

\begin{center}
\begin{tabular}{rr|rrrrrrr}
$A$ & $B$ & $\lnot A$ & $\lnot B$ & $A \land B$ & $A \lor B$ & $A \Rightarrow B$ & $A \Leftrightarrow B$ \\
\hline
0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 \\
1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}

$\lnot A$ өрнегі -- $A$ - ға теріс мән.
$A \land B$ өрнегі -- егер $A$ мен $B$
екеуі де ақиқат болса, ақиқат, ал $A \lor B$ өрнегі --
$A$ мен $B$-ның бірі немесе екеуі де ақиқат болса,
ақиқат.
$A \Rightarrow B$ өрнегі --
әрдайым $A$ ақиқат және $B$ да ақиқат болса,
ақиқат. $A \Leftrightarrow B$ өрнегі --
егер $A$ мен $B$ екеуі де ақиқат немесе жалған болса, ақиқат.

\index{Предикат}

\key{Предикат} -- ақиқат не жалған болуы параметрлерге байланысты өрнек.
Предикаттар әдетте бас әріппен белгіленеді.
Мысалы, $P(x)$ $x$ саны жай болғанда ғана
ақиқат деп белгілейік.
Сәйкесінше, $P(7)$ -- ақиқат, $P(8)$ -- жалған.

\index{квантор}

\key{Квантор} логикалық өрнекті
жиын элементтерімен байланыстырады.
Ең маңызды кванторлар --
$\forall$ (\key{жалпылық}) және $\exists$ (\key{бар болу}).
Мысалы,
\[\forall x (\exists y (y < x))\]
жиындағы әр $x$ элементі үшін өзінен 
кішірек болатын $y$ элементі бар деген мағынаны білдіреді.
Бұл бүтін сандар жиыны үшін ақиқат болса,
натурал сандар жиыны үшін жалған.

Жоғарыда берілген түсініктемеге сәйкес
көптеген логикалық тұжырымдарды өрнектей аламыз.

Үлгіде егер $x$ 1-ден үлкен және жай сан болмаса,
\[\forall x ((x>1 \land \lnot P(x)) \Rightarrow (\exists a (\exists b (a > 1 \land b > 1 \land x = ab))))\].
демек екеуі де 1-ден үлкен, көбейтінділері $x$-ке 
тең $a$ және $b$ сандары бар.
Тұжырымдама -- бүтін сандар үшін ақиқат.

\subsubsection{Функциялар}

$\lfloor x \rfloor$ функциясы $x$ санын
бүтінге дейін төменге дөңгелектейді, ал
$\lceil x \rceil$ $x$ санын
бүтінге дейін жоғарыға дөңгелектейді. 
Мысалы,
\[ \lfloor 3/2 \rfloor = 1 \hspace{10px} \textrm{және} \hspace{10px} \lceil 3/2 \rceil = 2.\]

$\min(x_1,x_2,\ldots,x_n)$ және $\max(x_1,x_2,\ldots,x_n)$ функциялары
$x_1,x_2,\ldots,x_n$ аралығандағы  ең аз және ең көп сәйкес мәндерді қайтарады.
Мысалы,
\[ \min(1,2,3)=1 \hspace{10px} \textrm{және} \hspace{10px} \max(1,2,3)=3.\]

\index{Факториал}

\key{$n!$} факториалы төмендегі формула бойынша:
\[\prod_{x=1}^n x = 1 \cdot 2 \cdot 3 \cdot \ldots \cdot n\]
немесе рекуррентті анықталады: 
\[
\begin{array}{lcl}
0! & = & 1 \\
n! & = & n \cdot (n-1)! \\
\end{array}
\]

\index{Фибоначчи сандары}



%Ескерту: {Фибоначчи шамамен 1175-1250 жылдары өмір сүрген итальяндық математик.

%footnote{Fibonacci (c. 1175--1250) was an Italian mathematician.}
\key{Фибоначчи сандары} көп жағдайда туындайды. Оларды төмендегі рекуррентті қатынас арқылы анықтауға болады:
\[
\begin{array}{lcl}
f(0) & = & 0 \\
f(1) & = & 1 \\
f(n) & = & f(n-1)+f(n-2) \\
\end{array}
\]
Алғашқы Фибоначчи сандары:
\[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \ldots\]
Фибоначчи сандарын анықтау үшін келесі тұйық формуланы қолдана аламыз. Ол кейде \index{Бине формуласы}
\key{Бине формуласы} деп те аталады:
\[f(n)=\frac{(1 + \sqrt{5})^n - (1-\sqrt{5})^n}{2^n \sqrt{5}}.\]

\subsubsection{Логарифмдер}

\index{логарифм}

$x$ санының \key{логарифмі}
$\log_k(x) $ ретінде белгіленеді, бұл жердегі $k$
логарифм негізі.
Анықтама бойынша,
$k^a=x$ болған жағдайда ғана $\log_k(x)=a$.

Логарифмнің пайдалы қасиеті --
$\log_k(x)$ арқылы $x$-тен 1-ге жету үшін 
$k$ санына қанша мәрте бөлу қажеттігін есептеуінде.
Мысалы, $\log_2(32)=5$,
себебі 2-ге 5 рет бөлеміз:

\[32 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1 \]

Алгоритмдерге талдау жасауда логарифмдер жиі қолданылады, 
себебі көптеген тиімді алгоритмдер әр қадам сайын әлденені 
екі есеге қысқартады.
Осылайша, кей алгоритмдердің тиімділігіне логарифмдер арқылы баға бере аламыз.

Көбейтінді логарифмі 
\[\log_k(ab) = \log_k(a)+\log_k(b),\]
сәйкесінше,
\[\log_k(x^n) = n \cdot \log_k(x).\]
Сондай-ақ, бөлінді логарифмі 
\[\log_k\Big(\frac{a}{b}\Big) = \log_k(a)-\log_k(b).\]
Тағы бір пайдалы формула: 
\[\log_u(x) = \frac{\log_k(x)}{\log_k(u)},\]
оның көмегімен кез-келген негіздегі логарифмді әлдеқандай 
белгілі негіз арқылы таба аламыз.

\index{натурал логорифм}

$\ln(x)$ негізі 
$e \approx 2.71828$ болатын
$x$ санының \key{натурал логарифмін} білдіреді.
Логарифмдердің қасиеті:
$b$ негізіндегі $x$ бүтін санының цифрлар мөлшерін
$\lfloor \log_b(x)+1 \rfloor$ арқылы біле аламыз.
Мысалы, $123$-тің негізі $2$ болса, 
көрсетілімі -- 1111011, сәйкесінше,
$\lfloor \log_2(123)+1 \rfloor = 7$ болады.

\section{Контесттер және ресурстар}

\subsubsection{IOI}

Информатикадан Халықаралық Олимпиада(IOI) --
жоғарғы сынып оқушыларына арналған бағдарламалау контесті.
Жарысқа әр елден 4 оқушыдан құралған команда қатыса алады.
Әдетте шамамен 80 елден жиналған 300 қатысушы арасында өтеді.

IOI 5 сағатқа созылатын екі контесттен тұрады.
Екі кезеңде де қатысушыларға 3 түрлі деңгейдегі 
алгоритмдік есептер ұсынылады.
Олар ішесептерге бөлініп,
әрбір ішесеп үшін нақты ұпайлар белгіленеді.
Қатысушылар командаларға бөлінгенімен, 
әрқайсысы жеке дара контестке түседі.

IOI силлабусы \cite{iois} IOI есептерінің болжамды
тақырыптарын реттейді.
Кітапта IOI силлабусының түгелге дерлік тақырыптары
қамтылған.

IOI қатысушылары ұлттық олимпиадалар арқылы іріктеледі.
IOI-дан бұрын Балтық информатика олимпиадасы (BOI),
Орталық Еуропа Информатикалық олимпиадасы (CEOI)
және Азия-Тынық мұхиты Информатика Олимпиадасы (APIO) сияқты өңірлік контесттер ұйымдастырылады.

Кей елдерде болашақ IOI қатысушыларына арналған онлайн контесттер ұйымдастырылады.
Мысалы, Croatian Open Competition in Informatics \cite{coci}
және the USA Computing Olympiad \cite{usaco}.
Сондай-ақ көптеген Поляк контесттерінің есептері онлайн қолжетімді\cite{main}.

\subsubsection{ICPC}

Студенттердің Халықаралық Бағдарламалау Сайысы (ICPC)
жыл сайын университет студенттеріне арнап өткізіледі.
Әр  командада 3 қатысушыдан болады.
IOI-дан айырмашылығы -- студенттер бірлесіп жұмыс жасайды,
әр команда үшін бір компьютер беріледі.

ICPC бірнеше кезеңнен тұрады, үздік
командалар Әлемдік Біріншілікке шақырылады.
Мыңдаған қатысушылардың арасынан іріктеліп, финалға
тек санаулысы өте алады\footnote{Қатысушылар саны жыл сайын өзгеріп отырады; 2017 жылғы қатысушылар саны -- 133.},
сондықтан финалға өтудің өзі үлкен жетістік деп саналады.

Әр ICPC контестінде 5 сағат ішінде командалар
шамамен 10 алгоритмдік есеп шығаруы қажет.
Есеп шешімі барлық тестілік жағдайды тиімді шешсе ғана
қабылданады.
Контест барысында командалар бір-бірінің нәтижелерін көре алады,
бірақ соңғы сағаттағы нәтижелер мен соңғы жіберілген шешімдерді көру мүмкіндігі шектелген.

ICPC-да болжамды тақырыптар IOI-дағыдай көрсетілмейді.
Десе де, ICPC терең білімді, әсіресе математикалық қабілеттілікті қажет етеді.

\subsubsection{Онлайн контесттер}

Жоғарыда аталған сайыстармен бірге көпшілікке арналған онлайн контесттерді де атап өтуге болады.
Қазіргі таңдағы ең белсенді контесттер сайты -- Codeforces,
онда шамамен апта сайын контесттер ұйымдастырылып тұрады.
Codeforces-та жаңа қатысушылар -- Div2, ал тәжірибелі қатысушылар -- Div1 деп аталатын екі дивизионға бөлінеді.
Контесттер ұйымдастырылатын сайттардың қатарында AtCoder, CS Academy, HackerRank және Topcoder-ді де атап өтуге болады. 

Кейбір компаниялар финалы офлайн болатын онлайн контесттерді ұйымдастырады.
Мысалы: Facebook Hacker Cup,
Google Code Jam мен Yandex.Algorithm.
Әрине, компаниялар бұл контесттерді қызметкерлерді жинақтау үшін де өткізеді. Өйткені контестте жақсы нәтиже көрсету арқылы қатысушылар бағдарламалау қабілеттерін көрсетуге мүмкіндік алады.

\subsubsection{Кітаптар}

Спорттық бағдарламалау мен алгоритмдік есептерді шығаруға бағытталған
бірнеше кітаптар тізімі (қолыңыздағы кітапты санамағанда) :

\begin{itemize}
\item S. S. Skiena and M. A. Revilla: 
\emph{Programming Challenges: The Programming Contest Training Manual} \cite{ski03}
\item S. Halim and F. Halim:
\emph{Competitive Programming 3: The New Lower Bound of Programming Contests} \cite{hal13}
\item K. Diks et al.: \emph{Looking for a Challenge? The Ultimate Problem Set from
the University of Warsaw Programming Competitions} \cite{dik12}
\end{itemize}

Алғашқы екі кітап жаңадан бастаушыларға арналса, соңғысы ілгері деңгейдегілерге арнап жазылған.

Спорттық бағдарламалауды зерделеуде пайдалы жалпы алгоритмдер жайлы  кітаптар бар.
Олардың ішіндегі кейбір танымалдары:

\begin{itemize}
\item T. H. Cormen, C. E. Leiserson, R. L. Rivest and C. Stein:
\emph{Introduction to Algorithms} \cite{cor09}
\item J. Kleinberg and É. Tardos:
\emph{Algorithm Design} \cite{kle05}
\item S. S. Skiena:
\emph{The Algorithm Design Manual} \cite{ski08}
\end{itemize}
